/*
 Copyright (C) 2012 Andy Karpov <andy.karpov@gmail.com>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.
 */

// STL headers
// C headers
#include <avr/pgmspace.h>
// Framework headers
// Library headers
#include <SPI.h>
// Project headers
// This component's header
#include <VS1003.h>

const uint8_t vs1003_chunk_size = 32;

#undef PROGMEM
#define PROGMEM __attribute__ ((section (".progmem.data")))
#undef PSTR
#define PSTR(s) (__extension__({static char __c[] PROGMEM = (s); &__c[0];}))

/****************************************************************************/

// VS1003 SCI Write Command byte is 0x02
#define VS_WRITE_COMMAND 0x02

// VS1003 SCI Read COmmand byte is 0x03
#define VS_READ_COMMAND  0x03

// SCI Registers

const uint8_t SCI_MODE = 0x0;
const uint8_t SCI_STATUS = 0x1;
const uint8_t SCI_BASS = 0x2;
const uint8_t SCI_CLOCKF = 0x3;
const uint8_t SCI_DECODE_TIME = 0x4;
const uint8_t SCI_AUDATA = 0x5;
const uint8_t SCI_WRAM = 0x6;
const uint8_t SCI_WRAMADDR = 0x7;
const uint8_t SCI_HDAT0 = 0x8;
const uint8_t SCI_HDAT1 = 0x9;
const uint8_t SCI_AIADDR = 0xa;
const uint8_t SCI_VOL = 0xb;
const uint8_t SCI_AICTRL0 = 0xc;
const uint8_t SCI_AICTRL1 = 0xd;
const uint8_t SCI_AICTRL2 = 0xe;
const uint8_t SCI_AICTRL3 = 0xf;
const uint8_t SCI_num_registers = 0xf;

// SCI_MODE bits

const uint8_t SM_DIFF = 0;
const uint8_t SM_LAYER12 = 1;
const uint8_t SM_RESET = 2;
const uint8_t SM_OUTOFWAV = 3;
const uint8_t SM_EARSPEAKER_LO = 4;
const uint8_t SM_TESTS = 5;
const uint8_t SM_STREAM = 6;
const uint8_t SM_EARSPEAKER_HI = 7;
const uint8_t SM_DACT = 8;
const uint8_t SM_SDIORD = 9;
const uint8_t SM_SDISHARE = 10;
const uint8_t SM_SDINEW = 11;
const uint8_t SM_ADPCM = 12;
const uint8_t SM_ADCPM_HP = 13;
const uint8_t SM_LINE_IN = 14;

// Register names

char reg_name_MODE[] PROGMEM = "MODE";
char reg_name_STATUS[] PROGMEM  = "STATUS";
char reg_name_BASS[] PROGMEM  = "BASS";
char reg_name_CLOCKF[] PROGMEM  = "CLOCKF";
char reg_name_DECODE_TIME[] PROGMEM  = "DECODE_TIME";
char reg_name_AUDATA[] PROGMEM  = "AUDATA";
char reg_name_WRAM[] PROGMEM  = "WRAM";
char reg_name_WRAMADDR[] PROGMEM  = "WRAMADDR";
char reg_name_HDAT0[] PROGMEM  = "HDAT0";
char reg_name_HDAT1[] PROGMEM  = "HDAT1";
char reg_name_AIADDR[] PROGMEM  = "AIADDR";
char reg_name_VOL[] PROGMEM  = "VOL";
char reg_name_AICTRL0[] PROGMEM  = "AICTRL0";
char reg_name_AICTRL1[] PROGMEM  = "AICTRL1";
char reg_name_AICTRL2[] PROGMEM  = "AICTRL2";
char reg_name_AICTRL3[] PROGMEM  = "AICTRL3";

static PGM_P register_names[] PROGMEM =
{
  reg_name_MODE,
  reg_name_STATUS,
  reg_name_BASS,
  reg_name_CLOCKF,
  reg_name_DECODE_TIME,
  reg_name_AUDATA,
  reg_name_WRAM,
  reg_name_WRAMADDR,
  reg_name_HDAT0,
  reg_name_HDAT1,
  reg_name_AIADDR,
  reg_name_VOL,
  reg_name_AICTRL0,
  reg_name_AICTRL1,
  reg_name_AICTRL2,
  reg_name_AICTRL3,
};


#define CODE_SIZE 527
const unsigned char atab[527] = { /* Register addresses */
    0x7, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x7,
    0x6, 0x6, 0x7, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x7, 0x6, 0x6, 0x7, 0x6, 0x6
};
const unsigned short dtab[527] = { /* Data to write */
    0x8030, 0x2800, 0x38c0, 0x0006, 0x2016, 0x3613, 0x0024, 0x0006,
    0x0057, 0x3e15, 0x1c15, 0x0020, 0x1fd4, 0x3580, 0x3802, 0xf204,
    0x3804, 0x0fff, 0xfe44, 0xa244, 0x1804, 0xf400, 0x4094, 0x2800,
    0x0f85, 0x3009, 0x1bc2, 0xf400, 0x4500, 0x2000, 0x0000, 0x36f5,
    0x3c15, 0x3009, 0x3857, 0x0030, 0x0a57, 0x3e14, 0xf806, 0x3701,
    0x8024, 0x0006, 0x0017, 0x3e04, 0x9c13, 0x0020, 0x1fd2, 0x3b81,
    0x8024, 0x36f4, 0xbc13, 0x36f4, 0xd806, 0x0030, 0x0717, 0x2100,
    0x0000, 0x3f05, 0xdbd7, 0x3613, 0x0024, 0x3e22, 0xb815, 0x3e05,
    0xb814, 0x3615, 0x0024, 0x3405, 0x9014, 0x36e3, 0x0024, 0x2000,
    0x0000, 0x36f2, 0x9815, 0x3613, 0x0024, 0x3e22, 0xb815, 0x3e05,
    0xb814, 0x3615, 0x0024, 0x3405, 0x9014, 0x36e3, 0x0024, 0x2000,
    0x0000, 0x36f2, 0x9815, 0x3613, 0x0024, 0x3e12, 0xb817, 0x3e12,
    0x3815, 0x3e05, 0xb814, 0x3615, 0x0024, 0x0000, 0x800a, 0x3e10,
    0x3801, 0x3e10, 0xb804, 0x3e01, 0x7810, 0x0030, 0x00d0, 0x2900,
    0x0400, 0x3001, 0x0024, 0x4080, 0x03cc, 0x3000, 0x0024, 0x2800,
    0x36c5, 0x4090, 0x0024, 0x0000, 0x0024, 0x2800, 0x2485, 0x0000,
    0x0024, 0x0000, 0x0081, 0x3000, 0x0024, 0x6012, 0x0024, 0x0000,
    0x0401, 0x2800, 0x3305, 0x0000, 0x0024, 0x6012, 0x0024, 0x0000,
    0x0024, 0x2800, 0x2885, 0x0000, 0x0024, 0x2900, 0x0c80, 0x0000,
    0x0024, 0x4088, 0x008c, 0x0000, 0x2000, 0x6400, 0x0024, 0x0000,
    0x3c00, 0x2800, 0x2118, 0x0000, 0x0024, 0x2800, 0x2540, 0x3801,
    0x0024, 0x6400, 0x038c, 0x0000, 0x0024, 0x2800, 0x2558, 0x0000,
    0x0024, 0x3013, 0x0024, 0x2900, 0x0400, 0x3801, 0x0024, 0x4080,
    0x0024, 0x0000, 0x0024, 0x2800, 0x2495, 0x0000, 0x0024, 0x6890,
    0x03cc, 0x2800, 0x36c0, 0x3800, 0x0024, 0x2900, 0x0c80, 0x0030,
    0x0110, 0x3800, 0x0024, 0x0000, 0x3c00, 0x6400, 0x0024, 0x003f,
    0xff00, 0x2800, 0x2d48, 0x0000, 0x0024, 0x0000, 0x3fc0, 0x6400,
    0x0024, 0x0000, 0x3c00, 0x2800, 0x3605, 0x6400, 0x0024, 0x0000,
    0x0024, 0x2800, 0x3615, 0x0000, 0x0024, 0xb880, 0x184c, 0x2900,
    0x0400, 0x3009, 0x3800, 0x4082, 0x9bc0, 0x6014, 0x0024, 0x0000,
    0x3c04, 0x2800, 0x2b81, 0x0000, 0x3dc1, 0x2900, 0x0c80, 0x0000,
    0x0024, 0xf400, 0x4004, 0x0000, 0x3dc1, 0x6412, 0x0024, 0x0030,
    0x0090, 0x2800, 0x2cc5, 0x0000, 0x0000, 0x0000, 0x0400, 0x2800,
    0x36c0, 0x3800, 0x0024, 0x0030, 0x00d0, 0x3001, 0x4024, 0xa50a,
    0x0024, 0x0000, 0x03c0, 0xb50a, 0x0024, 0x0000, 0x0300, 0x6500,
    0x0024, 0x0000, 0x0024, 0x2900, 0x0408, 0x0000, 0x3188, 0x0000,
    0x0380, 0x6500, 0x0024, 0x0000, 0x0024, 0x2800, 0x33d5, 0x0000,
    0x0024, 0x2900, 0x0400, 0x0000, 0x0024, 0x4080, 0x03cc, 0x0000,
    0x0080, 0x2800, 0x3315, 0x0000, 0x0024, 0x2800, 0x36c0, 0x3800,
    0x0024, 0x2900, 0x0c80, 0x0000, 0x0024, 0x408a, 0x0024, 0x0030,
    0x0110, 0x3613, 0x0024, 0x3e11, 0x4024, 0x30f0, 0x0024, 0x3e10,
    0x0024, 0x3000, 0x4024, 0x2926, 0xa140, 0x3e00, 0x4024, 0x36d3,
    0x0024, 0x0000, 0x0000, 0x0030, 0x0090, 0x3800, 0x0024, 0x36f1,
    0x5810, 0x36f0, 0x9804, 0x36f0, 0x1801, 0x3405, 0x9014, 0x36f3,
    0x0024, 0x36f2, 0x1815, 0x2000, 0x0000, 0x36f2, 0x9817, 0x002b,
    0x1105, 0x0030, 0x00d2, 0x0030, 0x0690, 0x0030, 0x0291, 0x0000,
    0x0084, 0x0006, 0x6853, 0x3e05, 0xb814, 0x3635, 0x0024, 0x0000,
    0x800a, 0xb880, 0x0024, 0x3800, 0x0024, 0x3910, 0x0024, 0x0000,
    0xc0c0, 0x3900, 0x0024, 0x0006, 0x0051, 0x0030, 0x0000, 0x2910,
    0x3740, 0x3a00, 0x0024, 0xb880, 0x010c, 0x38e0, 0x184c, 0x3800,
    0x0024, 0x3800, 0x0024, 0x0000, 0x0f00, 0x0006, 0x0010, 0x3009,
    0x2c00, 0x0003, 0x1e40, 0x3009, 0x2410, 0x0006, 0x0011, 0x3009,
    0x2410, 0x0030, 0x0ad0, 0x3800, 0x0024, 0x0000, 0x09c0, 0x0030,
    0x0690, 0x2910, 0x7780, 0x3800, 0x0024, 0x0001, 0x0010, 0xb882,
    0x0024, 0x291d, 0x5800, 0x0002, 0xdc00, 0x001f, 0xff00, 0x0003,
    0xda90, 0x2926, 0x1440, 0x3800, 0x0024, 0x2926, 0x0e40, 0x0030,
    0x0490, 0x6890, 0x0024, 0x3800, 0x0024, 0x2900, 0x1740, 0x0000,
    0x8001, 0x2919, 0x8180, 0x3613, 0x0024, 0x6012, 0x0024, 0x0003,
    0xd950, 0x2800, 0x4498, 0x0000, 0x0024, 0x2919, 0x8180, 0x3613,
    0x104c, 0x2928, 0xce40, 0x3c00, 0x0024, 0x0000, 0x1000, 0x2900,
    0x0a80, 0x34f1, 0x0024, 0xb882, 0x0042, 0x30f0, 0xc024, 0x4dc2,
    0x0024, 0x3810, 0x0024, 0x2800, 0x4480, 0x38f0, 0x4024, 0x5800,
    0x1800, 0x1800, 0x8010, 0xf400, 0x4095, 0x0006, 0x0017, 0x3009,
    0x1c40, 0x3009, 0x1fc2, 0x6020, 0x0024, 0x0000, 0x1fc2, 0x2000,
    0x0000, 0xb020, 0x4542, 0x3009, 0x3857, 0x2800, 0x1080, 0x0030,
    0x0457, 0x8025, 0x2a00, 0x100e, 0x8022, 0x2a00, 0x060e
};

/****************************************************************************/

/**
 * Spi saver
 *
 * Easy way to pop the SPI config registers onto the stack and pop
 * them off again
 */
struct spi_saver_t
{
  uint8_t saved_SPCR;
  uint8_t saved_SPSR;

  spi_saver_t(void)
  {
    saved_SPCR = SPCR;
    saved_SPSR = SPSR;
  }
  ~spi_saver_t()
  {
    SPCR = saved_SPCR;
    SPSR = saved_SPSR;
  }
};

/****************************************************************************/

uint16_t VS1003::read_register(uint8_t _reg) const
{
  uint16_t result;
  control_mode_on();
  delayMicroseconds(1); // tXCSS
  SPI.transfer(VS_READ_COMMAND); // Read operation
  SPI.transfer(_reg); // Which register
  result = SPI.transfer(0xff) << 8; // read high byte
  result |= SPI.transfer(0xff); // read low byte
  delayMicroseconds(1); // tXCSH
  await_data_request();
  control_mode_off();
  return result;
}

/****************************************************************************/

void VS1003::write_register(uint8_t _reg,uint16_t _value) const
{
  control_mode_on();
  delayMicroseconds(1); // tXCSS
  SPI.transfer(VS_WRITE_COMMAND); // Write operation
  SPI.transfer(_reg); // Which register
  SPI.transfer(_value >> 8); // Send hi byte
  SPI.transfer(_value & 0xff); // Send lo byte
  delayMicroseconds(1); // tXCSH
  await_data_request();
  control_mode_off();
}

/****************************************************************************/

void VS1003::sdi_send_buffer(const uint8_t* data, size_t len)
{
  data_mode_on();
  while ( len )
  {
    await_data_request();
    delayMicroseconds(3);

    size_t chunk_length = min(len,vs1003_chunk_size);
    len -= chunk_length;
    while ( chunk_length-- )
      SPI.transfer(*data++);
  }
  data_mode_off();
}

/**
 * send a MIDI message
 *
 * a MIDI message ranges from 1 byte to three bytes
 * the first byte consists of 4 command bits and 4 channel bits
 * 
 * based on talkMIDI function in MP3_Shield_RealtimeMIDI demo by Matthias Neeracher,
 * which is based on Nathan Seidle's Sparkfun Electronics example
 */
 
void VS1003::sendMidiMessage(uint8_t cmd, uint8_t data1, uint8_t data2)
{
    int len = 4;
    uint8_t data[6] ={0x00, cmd, 0x00, data1};
    // Some commands only have one data byte. All cmds less than 0xBn have 2 data bytes 
    // (sort of: http://253.ccarh.org/handout/midiprotocol/)
    if( (cmd & 0xF0) <= 0xB0 || (cmd & 0xF0) >= 0xE0) {
      data[4]=0x00;
      data[5]=data2;
      len = 6;
    } 
    sdi_send_buffer(data, len);
}


/****************************************************************************/

void VS1003::sdi_send_zeroes(size_t len)
{
  data_mode_on();
  while ( len )
  {
    await_data_request();

    size_t chunk_length = min(len,vs1003_chunk_size);
    len -= chunk_length;
    while ( chunk_length-- )
      SPI.transfer(0);
  }
  data_mode_off();
}

/****************************************************************************/

VS1003::VS1003( uint8_t _cs_pin, uint8_t _dcs_pin, uint8_t _dreq_pin, uint8_t _reset_pin):
  cs_pin(_cs_pin), dcs_pin(_dcs_pin), dreq_pin(_dreq_pin), reset_pin(_reset_pin)
{
}

/****************************************************************************/
void VS1003::beginMidi(void)
{
  printf_P(PSTR("MIDI initialization...\r\n"));
  loadMidiCode();
  printf_P(PSTR("User code loaded...\r\n"));
  write_register(0xA , 0x30); // setting VS1003 Start adress for user code
  printf_P(PSTR("Start address changed...\r\n"));
  delay(500);
  int check = read_register(SCI_AUDATA);
  if (check==0xac45){
    printf_P(PSTR("MIDI ready...\r\n"));
  } else {
    printf_P(PSTR("Not in MIDI Mode?\r\n"));
    printf_P(PSTR("SCI_AUDATA = 0x%02x \r\n"));
  }
}

void VS1003::begin(void)
{
  spi_saver_t spi_saver;

  // Keep the chip in reset until we are ready
  pinMode(reset_pin,OUTPUT);
  digitalWrite(reset_pin,LOW);

  // The SCI and SDI will start deselected
  pinMode(cs_pin,OUTPUT);
  digitalWrite(cs_pin,HIGH);
  pinMode(dcs_pin,OUTPUT);
  digitalWrite(dcs_pin,HIGH);

  // DREQ is an input
  pinMode(dreq_pin,INPUT);

  // Boot VS1003
  printf_P(PSTR("Booting VS1003...\r\n"));

  delay(1);

  // init SPI slow mode
  SPI.setClockDivider(SPI_CLOCK_DIV64); // Slow!

  // release from reset
  digitalWrite(reset_pin,HIGH);

  // Declick: Immediately switch analog off
  write_register(SCI_VOL,0xffff); // VOL

  /* Declick: Slow sample rate for slow analog part startup */
  write_register(SCI_AUDATA,10);

  delay(100);

  /* Switch on the analog parts */
  write_register(SCI_VOL,0xfefe); // VOL

  printf_P(PSTR("VS1003 still booting\r\n"));

  write_register(SCI_AUDATA,44101); // 44.1kHz stereo

  write_register(SCI_VOL,0x2020); // VOL

  // soft reset
  write_register(SCI_MODE, _BV(SM_SDINEW) | _BV(SM_RESET));
  delay(1);
  await_data_request();
  write_register(SCI_CLOCKF,0xB800); // Experimenting with higher clock settings
  delay(1);
  await_data_request();

  // Now you can set high speed SPI clock
  SPI.setClockDivider(SPI_CLOCK_DIV4); // Fastest available

  printf_P(PSTR("VS1003 Set\r\n"));
  printDetails();
  printf_P(PSTR("VS1003 OK\r\n"));

  // Having set up our SPI state just the way we like it, save it for next time
  save_our_spi();
}

/****************************************************************************/

void VS1003::setVolume(uint8_t vol) const
{
  uint16_t value = vol;
  value <<= 8;
  value |= vol;

  write_register(SCI_VOL,value); // VOL
}

/****************************************************************************/

void VS1003::startSong(void)
{
  spi_saver_t spi_saver;
  set_our_spi();
  sdi_send_zeroes(10);
}

/****************************************************************************/

void VS1003::playChunk(const uint8_t* data, size_t len)
{
  spi_saver_t spi_saver;
  set_our_spi();
  sdi_send_buffer(data,len);
}

/****************************************************************************/

void VS1003::stopSong(void)
{
  spi_saver_t spi_saver;
  set_our_spi();
  sdi_send_zeroes(2048);
}

/****************************************************************************/

void VS1003::print_byte_register(uint8_t reg) const
{
  const char *name = reinterpret_cast<const char*>(pgm_read_word( register_names + reg ));
  char extra_tab = strlen_P(name) < 5 ? '\t' : 0;
  printf_P(PSTR("%02x %S\t%c = 0x%02x\r\n"),reg,name,extra_tab,read_register(reg));
}

/****************************************************************************/

void VS1003::printDetails(void) const
{
  spi_saver_t spi_saver;
  printf_P(PSTR("VS1003 Configuration:\r\n"));
  int i = 0;
  while ( i <= SCI_num_registers )
    print_byte_register(i++);
}

/****************************************************************************/

void VS1003::loadUserCode(const uint16_t* buf, size_t len) const
{
  while (len)
  {
    uint16_t addr = pgm_read_word(buf++); len--;
    uint16_t n = pgm_read_word(buf++); len--;
    if (n & 0x8000U) { /* RLE run, replicate n samples */
      n &= 0x7FFF;
      uint16_t val = pgm_read_word(buf++); len--;
      while (n--) {
	      printf_P(PSTR("W %02x: %04x\r\n"),addr,val);
        write_register(addr, val);
      }
    } else {           /* Copy run, copy n samples */
      while (n--) {
	      uint16_t val = pgm_read_word(buf++); len--;
	      printf_P(PSTR("W %02x: %04x\r\n"),addr,val);
        write_register(addr, val);
      }
    }
  }
}

void VS1003::loadMidiCode() const
{
  int i;
  for (i=0;i<CODE_SIZE;i++) {
    write_register(atab[i], dtab[i]);
  }
}

/****************************************************************************/

// vim:cin:ai:sts=2 sw=2 ft=cpp
